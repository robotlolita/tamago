% language: tamago
/// Arbitrary-precision integer values.
namespace tamago::maths::integer

use tamago::native::unsafe::types as Types;
use tamago::native::unsafe::integer as N;
use tamago::base::ordering exposing less-than, equal, greater-than;

#category Types
define Integer = Types.Integer;

# category Comparison
define self === that = N.eq(self, that);
define self =/= that = N.not-eq(self, that);

define self compare-to: that =
  N.compare(self, that, less-than, equal, greater-than);

define self < that = N.lt(self, that);
define self <= that = N.lte(self, that);
define self > that = N.gt(self, that);
define self >= that = N.gte(self, that);

#category Arithmetic
define self + that = N.add(self, that);
define self - that = N.sub(self, that);
define self * that = N.mul(self, that);
define self / that = N.div(self, that);

define self remainder: that = N.remainder(self, that);

define self divide-and-remainder: that =
  {
    result = self / that,
    remainder = self divide-and-remainder: that
  };

define self ** that = N.power(self, that);

#category Bitwise
define self bit-shift-right: bits =
  N.bit-shr(self, bits);

define self bit-shift-left: bits =
  N.bit-shl(self, bits);

define self bit-and: mask =
  N.bit-and(self, mask);

define self bit-or: mask =
  N.bit-or(self, mask);

define self bit-xor: mask =
  N.bit-xor(self, mask);

define self bit-not =
  N.bit-not(self);

define self bit-at: position =
  N.bit-at(self, position);

define self bit-set-at: position =
  N.bit-set(self, position);

define self bit-clear-at: position =
  N.bit-clear(self, position);

define self bit-toggle-at: position =
  N.bit-toggle(self, position);

#category Conversions
define self to-float64 =
  N.to-float64(self);

define self to-digits-with-radix: radix =
  N.to-digits(self, radix);

define self to-binary-digits =
  self to-digits-with-radix: 2;

define self to-decimal-digits =
  self to-digits-with-radix: 10;

define self to-hexadecimal-digits =
  self to-digits-with-radix: 16;
