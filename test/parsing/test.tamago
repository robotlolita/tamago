% language: tamago
namespace examples::tamago::test-1

// Namespaces & Imports
use some::namespace::a as A;
use some::namespace::b exposing a, _ b, _ c: _, _ === _;
use some::namespace::c as B exposing c, d;

open A exposing b;


// Functions & tests
define a = b;
define a() = 1;
define a(b, _, c) = 2;
define a b = 3;
define a b: c d: e = 4;
define a === b = 5;

define _ hello = begin
  6;
where
  this-is-a-test;
  assert 1;
  assert 1 ==> 2;
  unreachable "oh noes";
end

test "a description goes here" = begin
  a-test-is-fine-too;
end

define calls() = begin
  a();
  a(b, c, d);
  a b;
  a b: c d e: f === 2 g: f();
  a === b;
  a(b) |> b(c);
  xs map: _ + 1 |> _ filter: _;
  fun(a, _, c) -> a + b;
end

define other = begin
  (whoa);
end


// Primitives
define primitives = begin
  [a, b, [c, d]];
  100;
  100.00;
  "hello";
  nothing;
  true; false;
end

// Data
define records = begin
  { a = 1, b, (sym) = 2 };
end

data A { some, field = 1 };
data Expr =
  | Var { name }
  | Lam { param, body }
  | App { callee, argument };

define more-records = begin
  A { some, field = 3 };
  Expr.Var { name = "oh noes" };

  a.some();
  a.(symbol-field)();
end


// Binding and control
define binds = begin
  let a = 1;
  let mutable b = 2;

  b <- c;

  if a then
    b;
  else if b then
    c;
  else if c then
    d;
  else
    e;
  end

  for x in xs begin
    do-something(x);
  end

  repeat with n = 0, m = 1 begin
    if n > 100 then
      break;
    end
    continue with n = m, m = n * m;
  end

  repeat
    break;
  end

  begin
    more;
    things;
    go;
    here;
  end
end

// Pattern matching
define patterns = begin
  match expr with
  | pattern when true => yay;
  | pattern => yay;
  | default => yay;
  end

  match value with
  | [] as x => x;
  | "1" => x;
  | 1 => x;
  | true => x;
  | nothing => x;
  | [a, b, [c]] => x;
  | { x, y = z, (sym) = yay } => yay;
  | ^expr() => yay;
  | a is Data => yay;
  | Data { f, g = [h], (x) = _ } => yay;
  | x => yay;
  | _ => yay;
  end
end

// Effects and handlers
default handler io with
| Write { text } => resume with nothing;
| Read {} => resume with "hello";
end

define handlers = begin
  do
    handle 
      let name = !io read;
      !io write: "hello, " ++ name;
    with
    | Write { text } => resume with nothing;
    | Read {} => resume with "hello";
    end
  end
end


// Processes
define processes = begin
  process
    yield 1;
    yield all [1, 2, 3];
  end
end


// Protocols
protocol Equality(a, b) with
  requires Thing(a);

  method a === b;
  method a =/= b = not (a === b);
end

implement Equality(Integer, Integer) with
  method a === b = int-equals(a, b);
end

implement Equality(Float, Float) with
  method a === b = float-equals(a, b);
  method a =/= b = float-nequals(a, b);
end